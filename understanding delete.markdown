Как работает оператор delete

1. Теория
    1. Тип кода
    2. Контекст выполнения
    3. Объект активации / Объект переменных
    4. Атрибуты свойств
    5. Встроенные свойства и DontDelete
    6. Необъявленные присвоения
2. Путаница с Firebug'ом
    1. Удаление переменных с помощью eval
3. Совместимость браузеров
    1. Баг DontDelete в Gecko
4. Баги IE
5. Заблуждения
6. `delete` and host objects
7. ES5 strict mode
8. Вывод

Пару недель назад мне попалась на глаза книга Стояна Стефанова (Stoyan Stefanov) [Объектно-ориентированный Javascript](http://www.amazon.com/Object-Oriented-JavaScript-high-quality-applications-libraries/dp/1847194141). У книги был настолько высокий рейтинг на Амазоне (12 обзоров на 5 звезд), что я решил просмотреть, нет ли в ней чего-нибудь что можно было бы порекомендовать другим. Мне очень понравилось как все описывается в разделе про функции, с которого я начал; поток примеров выстроен таким приятным и прогрессивным образом, что даже начинающие освоят его очень легко. Однако практически сразу я наткнулся на **интересное заблуждение,** описываемое на протяжении целой главы — удаление функций. Есть и другие ошибки (такие как разница между объявлением функции и оператором function), но сейчас мы не будем их обсуждать.

Книга утверждает, что “функции работают как обычные переменные — их можно скопировать в другую переменную или даже удалить”. И приводится следующий пример:

    >>> var sum = function(a, b) {return a + b;}
    >>> var add = sum;
    >>> delete sum
    true
    >>> typeof sum;
    "undefined"

Если не обращать внимания на пару отсутствующих точек с запятой, что еще не так с этим куском кода? Конечно, проблема в том, что удаление переменной sum не должно было пройти успешно; выражение с оператором delete не должно разрешаться в true и typeof sum не должно вернуть  “undefined”. Все потому, что в Javascript'е нельзя удалять переменные. По крайней мере, те, которые определены таким образом.

Так что же происходит в этом примере? Опечатка? Диверсия? Скорее всего нет. На самом деле весь этот отрывок кода скопирован из Firebug'а, который Стоян должно быть использовал для тестирования по-быстрому. Почти похоже что у Firebug'а какие-то свои правила по поводу удаления. Это Firebug сбил Стояна с толку! Так что же на самом деле здесь происходит?

Чтобы ответить на этот вопрос необходимо понимать как работает оператор delete в Javascript'е: что конкретно можно и нельзя удалять и почему. Сегодня я попытаюсь обяснить это подробнее. Мы изучим "странное" поведение Firebug'а и убедимся что оно не такое уж и странное; мы покопаемся в том что происходит за кулисами когда мы объявляем переменные и функции, назначаем свойства и удаляем их; мы посмотрим насколько браузеры соответствуют спецификации и познакомимся с некоторыми самыми общеизвестными багами; мы также поговорим о strict mode в 5-м издании ECMAScript, и о том, как он меняет поведение оператора delete.

Как Javascript так ECMAScript в тексте будут означать ECMAScript, если только мы не обсуждаем Mozilla-реализацию JavaScript™.

Как ни странно, в Сети довольно мало описаний работы оператора delete. Статья на MDC хотя, возможно, и самая исчерпывающая, но, к сожалению, не включает несколько интересных деталей. Интересно, что одна из этих деталей является причиной странного поведения Firebug'а. Статья же на MSDN практически бесполезна.

# Теория

Так почему мы можем удалять свойства объектов:

    var o = { x: 1 };
    delete o.x; // true
    o.x; // undefined

но не можем удалять переменные, определенные таким образом:

    var x = 1;
    delete x; // false
    x; // 1

или функции, объявленные вот так:

    function x(){}
    delete x; // false
    typeof x; // "function"

Обратите внимание что delete возвращает false только когда свойство нельзя удалить.

Чтобы все это понять, сначала необходимо полностью осознать такие понятия как создание переменных и атрибуты свойств — те вещи, которые, к несчастью, редко объясняются в книгах про Javascript. Я пробегусь очень кратко по этим понятиям в несколько параграфов. Понять их совсем не сложно! Если вам не интересно, почему все работает так а не иначе, просто пропустите эту главу.

## Тип кода

В ECMAScript 3 типа исполнаемого кода: Глобальный, Функциональный и Eval-код. В некоторый степени их названия говорят сами за себя, но я коротко поясню:

Когда с кодом работаюют как с Программой, он выполняется в глобальной области видимости и считается Глобальным кодом. В браузере, содержимое тега SCRIPT обычно парсится как Программа и таким образом выполняется как Глобальный код.  
Все что выполняется непосредственно внутри кода считается, очевидно, Функциональным кодом. В браузерах содержимое атрибутов-событий (например, `<p onclick="...">`) обычно парсится и выполняется как Функциональный код.  
И наконец, текст, который передается встроенной функции Eval парсится как Eval-код. Вскоре мы увидим, чем этот тип отличается.

## Контекст выполнения

Выполнение кода на ECMAScript всегда происходит в определенном контексте выполнения. Контекст выполнения — это, в некотором смысле, абстрактная сущность, которая помогает понимать, как работает область видимости и создание переменных. Для каждого из трех типов кода существует свой контекст выполнения. Когда выполняется функция, говорят, что управление переходит в контекст выполнения Функционального кода; когда выполняется Глобальный код, управление переходит в контекст выполнения Глобального кода и так далее.

Как можно заметить, контексты выполнения можно представить в виде стопку. Сначала может быть Глобальный код со своим контекстом, этот код может запускать фукнции, с их контекстом, в свою очередь функция может вызвать другую функцию и так далее. Даже если функция рекурсивно вызывает сама себя, при каждом вызове происходит переход в новый контекст выполнения.

## Объект активации / Объект переменных

Каждый контекст выполнения имеет связанный с ним так называемый Объект переменных. Также как и контекст выполнения, Объект переменных — это абстрактная сущность, механизм для описания процесса создания переменных. А теперь, интересное: переменные, и функции, определенные в исходном коде на самом деле добавляются как свойства к этому самому объекту.

Когда управление переходит контекст выполнения Глобального кода, в качестве Объекта переменных используется Глобальный объект. Именно поэтому переменные и функции объявленные глобально становятся свойствами Глобального объекта:

    /* "this" ссылается на Глобальный объект в глобальной области видимости */
    var GLOBAL_OBJECT = this;

    var foo = 1;
    GLOBAL_OBJECT.foo; // 1
    foo === GLOBAL_OBJECT.foo; // true

    function bar(){}
    typeof GLOBAL_OBJECT.bar; // "function"
    GLOBAL_OBJECT.bar === bar; // true

OK, глобальные переменные становятся свойствами Глобального объекта, но что происходит с локальными переменными, которые мы определяем в Функциональном коде? На самом деле все происходит примерно также: они становятся свойствами Объекта переменных. Единственное отличие в том, что внутри Функционального кода Объект переменных не Глобальный объект, а так называемый Объект активации. Объект активации создается каждый раз, когда происходит переход в контекст выполнения функции.

Кроме переменных и функций свойствами Объекта активации становятся и и переданные в функцию аргументы. Они получают имена указанные для них при определении функции — так называемые формальные параметры. Аргументы не указанные в формальных параметрах (и указанные тоже) становятся свойствами специального объекта arguments, который становится в свою очередь свойством Объекта активации. Обратите внимание, что Объект активации – это внутренний механизм, к нему нет доступа из кода программы.

    (function(foo){

      var bar = 2;
      function baz(){}

      /*
      Образно говоря,
      пециальный объект "arguments" становится свойством Объекта активации родительской фукнции:
        ACTIVATION_OBJECT.arguments; // Объект arguments

      ...так же как и аргумент "foo":
        ACTIVATION_OBJECT.foo; // 1

      ...как и переменная "bar":
        ACTIVATION_OBJECT.bar; // 2

      ...как и функция, определенная локально:
        typeof ACTIVATION_OBJECT.baz; // "function"
      */

    })(1);

И, наконец, переменные, объявленные внтури кода, пропущенного через Eval становятся свойствами Объекта переменных того контекста, откуда Eval был вызван. Eval-код попросту использует Объект переменных того контекста, в котором он был вызван:

    var GLOBAL_OBJECT = this;

    /* "foo" становится свойстовм Объекта переменных вызывающего контекста, в данном случае — Глобального объекта */

    eval('var foo = 1;');
    GLOBAL_OBJECT.foo; // 1

    (function(){

      /* `bar` становится свойстовм Объекта переменных вызывающего контекста, в данном случае — Объект активации родительской фукнции */

      eval('var bar = 1;');

      /*
        Образно говоря,,
        ACTIVATION_OBJECT.bar; // 1
      */

    })();

## Атрибуты свойств

Мы почти закончили. Теперь, когда понятно, что происходит с переменными (они становятся свойствами), осталось понять что такое атрибуты свойств. Каждое свойство может иметь или не иметь несколько атрибутов из следующего списка: ReadOnly (только для чтения), DontEnum (не участвует в итерациях each), DontDelete (неудалимое) and Internal (внутреннее). Можно представить их как флаги — атрибут либо есть у свойства либо его нет. В рамках сегодняшнего обсуждения нас интересует только свойство DontDelete.

Когда объявленные переменные и функции становятся свойствами Обекта переменных, либо Объекта активации (для функционального кода) либо Глобального объекта (для Глобального кода), эти свойства создаются с аттрибутом DontDelete. Однако все явные или неявные назначения свойств создают свойства без атрибута DontDelete. Именно поэтому мы можем удалять одни свойства и не можем — другие:

    var GLOBAL_OBJECT = this;

    /*  "foo" является свойством Глобального объекта. Она создается с помошью объявления переменной и следовательно имеет атрибут DontDelete. Поэтому ее нельзя удалить. */

    var foo = 1;
    delete foo; // false
    typeof foo; // "number"

    /*  "bar" является свойством Глобального объекта. Она создана с помошью объявления функции и следовательно имеет атрибут DontDelete. И поэтому ее тоже нельзя удалить. */

    function bar(){}
    delete bar; // false
    typeof bar; // "function"

    /*  "baz" также является свойством Глобального объекта. Однако она создана через назначение свойства и поэтому не имеет атрибута DontDelete. Именно поэтому ее можно удалить. */

    GLOBAL_OBJECT.baz = 'blah';
    delete GLOBAL_OBJECT.baz; // true
    typeof GLOBAL_OBJECT.baz; // "undefined"

## Встроенные свойства и DontDelete

Итак, речь об особом атрибуте свойства, который запрещает удаление этого свойства. Обратите внимание что некоторые свойства встроенных объектов имеют атрибут DontDelete и поэтому их нельзя удалить. Особая переменная arguments (она же — свойство Объекта активации) имеет атрибут DontDelete. У каждой функции свойство length также имеет этот атрибут:

    (function(){

      /* "arguments" нельзя удалить из-за DontDelete */

      delete arguments; // false
      typeof arguments; // "object"

      /* свойство фукнции "length" тоже нельзя удалить */

      function f(){}
      delete f.length; // false
      typeof f.length; // "number"

    })();

Свойства являющиеся аругментами фукнции тоже создаются с атрибутом DontDelete, и поэтому их тоже нельзя удалить:

    (function(foo, bar){

      delete foo; // false
      foo; // 1

      delete bar; // false
      bar; // 'blah'

    })(1, 'blah');

## Необъявленные присвоения

Как вы, наверное, помните необъявленные присвоения создают свойства Глобального объекта. Кроме случаев, когда одноименное свойство нашлось где-то в цепочки областей видимости раньше Глобального объекта. И теперь, когда мы знаем разницу между назначением свойства и объявлением переменной — последнее устанавливает DontDelete, а первое — нет, должно быть понятно почему необъявленные присвоеня создают удаляемые свойства:
    
    var GLOBAL_OBJECT = this;

    /* создает свойство глобального объекта с помощью объявления переменной; свойство имеет атрибут DontDelete */
    var foo = 1;

    /* создает свойство глобального объекта с помошью необъявленного присвоения; свойство не имеет атрибута DontDelete */
    bar = 2;

    delete foo; // false
    typeof foo; // "number"

    delete bar; // true
    typeof bar; // "undefined"


Обратите внимание, что атрибуты задается только в момент создания свойства (например, ни один из атрибутов не задан). Последующие присвоеня не меняют атрибутов существующих свойств. Это важно понимать.

    /* "foo" создана как свойство с атрибутом DontDelete */
    function foo(){}

    /* Последующие присвоения не изменяют атрибутов. DontDelete на месте! */
    foo = 1;
    delete foo; // false
    typeof foo; // "number"

    /* Но назначение свойства, которое еще не существует создает свойство без атрибутов (и, соотвественно, без DontDelete) */

    this.bar = 1;
    delete bar; // true
    typeof bar; // "undefined"

# Путаница с Файрбагом

Так что же происходи в Файрбаге? Почему, переменные созданные в консоли можно удалить, в противовес тому, что мы только что узнали? Ну, как было сказано ранее, у Eval-кода свой подход к объявлению переменных. Переменные, объявленные в Eval-коде на самом деле создаются как свойства без DontDelete:

    eval('var foo = 1;');
    foo; // 1
    delete foo; // true
    typeof foo; // "undefined"

и точно также в Функциональном коде:

    (function(){

      eval('var foo = 1;');
      foo; // 1
      delete foo; // true
      typeof foo; // "undefined"

    })();

В этом чуть необычного поведения Файрбага. Похоже, весь текст в консоли парсится и выполняется через Eval, а не как Глобальный или Функциональный код. Очевидно, что любые объявленные переменные становятся свойствами без атрибута DontDelete, и поэтому их можно легко удалить. Имейте в виду различия между обычным Глобальным кодом и консолью Файрбага.

## Удаление переменных с помощью Eval

Есть очень интересное поведение функции eval, которое вкупе с одним из аспектов ECMAScript технически может позволить удалять неудаляемые свойства. Дело в том, что объявления фукнций могут перезаписывать переменные с таким же именем в том же контексте выполнения:

    function x(){ }
    var x;
    typeof x; // "function"

Обратите внимание, как объявление функции перезаписывает одноименную переменную (или, другими словами, то же свойство Объекта переменных). Это происходит потому что объявления функций выполняются после объявления переменных и могут их перезаписывать. Причем объявления функций не только перезаписывают старые значения свойств, но и заменяют их атрибуты. Если мы объявим функцию через Eval, то эта фукнция должна также заменить атрибуты старого свойства своими. А так как переменные определенные с помощью eval создают свойства без атрибута DontDelete, определение этой новой фукнции должно удалить существующий атрибут DontDelete у нужной переменной, делая ту удаляемой (и она, конечно, заменит значение свойства на ссылку на вновь созданную функцию).

    var x = 1;

    /* Нельзя удалить, у "x" есть DontDelete */

    delete x; // false
    typeof x; // "number"

    eval('function x(){}');

    /* свойство "x" теперь является ссылкой на фукнцию и не должно иметь атрибута DontDelete */

    typeof x; // "function"
    delete x; // должно быть "true"
    typeof x; // должно быть "undefined"


К несчастью этот трюк не работает ни в одной из реализаций, которые я пробовал. Возможно, я что-то упустил, либо такое поведение слишком неясно и авторы реализаци не считают нужным обращать на него внимание.




